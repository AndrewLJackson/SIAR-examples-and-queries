---
title: "Comparing populations in isotope-space"
author: "Andrew L Jackson"
date: "14 July 2015"
output: html_document
---

```{r, echo=FALSE, message = FALSE, fig.width = 7, fig.height = 7}

library(siar, quietly = TRUE,
        verbose = FALSE,
        logical.return = FALSE)

source("plot.siber.data.r")

M <- plot.siber.data("../siber-scripts/example_layman_data.csv",
                tt = "Community 1", add.hull = F)
```

In this figure, we have 4 populations (or more generically: groups) of indivuals. We might want to make some comparisons of the isotopic (and hence ecological) niches occupied by these individuals. The two most obvious ways to compare two of these populations, is to ask whether their niches are located in the same place, and if they are the same size. Thereafter, we may be interested in asking to what extent do their niches overlap.

We can visualise this by adding both ellipses, and convex hulls to the data. In this case, we add standard ellipses, which are to bivariate data as standard deviations are to univariate data. A standard ellipse contains approximately 40% of the data, although they can be rescaled to contain any proporition of the data we wish if we accept the assumption that they multivariate normal distributed. Owing to this proportional representation of the data, the ellipse _should_ be insensitive to sample size, and _should_ always contain 40% of the data. However, as was demonstrated in the SIBER paper [Jackson et al 2010](https://scholar.google.com/citations?view_op=view_citation&hl=en&user=E0sB7fUAAAAJ&citation_for_view=E0sB7fUAAAAJ:_FxGoFyzp5QC), the basic Standard Ellipse Area (SEA) shows bias at small sample sizes, which can be corrected to calculate SEAc.

In contrast, the convex hull is a polygon that is drawn around the outermost points in the cloud of data such that all other points lie within the outline. If we were to go out and collect more samples, then this hull can only grow in size and not get smaller. The result of this is that smaller sample sizes will result in smaller convex hulls. Despite this statistical problem, the convex hull remains a useful way to help us visualise bivariate data such as carbon-nitrogen stable isotope values.

We can then go back to our community comprising 4 populations, and add standard ellipses and convex hulls to each group by first splitting the data into 4 groups, and then looping over these 4 groups and applying the ellipse and hull plotting instructions to each group, one at a time. This code is taken from the script (demo.SEA.r)[../siber-scripts/demo.SEA.r] which you can open seprately, or you can copy and paste from below (although you will need to alter the location of the data file in the opening code:

``` r
mydata<-read.csv("path/example_ellipse_data.csv"))
```

And now the full code...

```{r, fig.width = 6, fig.height = 4}

rm(list = ls()) # clear the memory of objects

# load the siar package of functions
library(siar)

# ------------------------------------------------------------------------------
# ANDREW - REMOVE THESE LINES WHICH SHOULD BE REDUNDANT
# change this line
#setwd("c:/rtemp")
#setwd("/Users/andrewjackson/Dropbox/siar/demo scripts and files/siber scripts")
#setwd( "D:/Alternative My Documents/Andrews Documents/Dropbox/siar/demo scripts and files/siber scripts")
# ------------------------------------------------------------------------------



# now close all currently open windows
graphics.off()


# read in some data
# NB the column names have to be exactly, "group", "x", "y"
mydata <- read.csv("../siber-scripts/example_ellipse_data.csv",header=T)

# make the column names availble for direct calling
# attach(mydata)
# NB I am phasing out use of the attach() function, and instead
# prefer to directly reference columns within data.frame objects
# by using, mydata$x, mydata$y and mydata$group etc...


# now loop through the data and calculate the ellipses
ngroups <- length(unique(mydata$group))



# split the isotope data based on group
spx <- split(mydata$x, mydata$group)
spy <- split(mydata$y, mydata$group)

# create some empty vectors for recording our metrics
SEA <- numeric(ngroups)
SEAc <- numeric(ngroups)
TA <- numeric(ngroups)

dev.new()
plot(mydata$x, mydata$y, col=mydata$group, type="p")
legend("topright",
       legend = as.character(paste("Group ",unique(mydata$group))),
       pch = 19,
       col = 1:length(unique(mydata$group)))

# a dataframe for collecting the 6 layman metrics, although see
# my note below for caveats.
group.layman.metrics <- data.frame(group = unique(mydata$group),
                                  dN_range = double(ngroups),
                                  dC_range = double(ngroups),
                                  TA = double(ngroups),
                                  CD = double(ngroups),
                                  MNND = double(ngroups),
                                  SDNND = double(ngroups)
                                  )

for (j in unique(mydata$group)){


  # Fit a standard ellipse to the data
  SE <- standard.ellipse(spx[[j]],spy[[j]],steps=1)
  
  # Extract the estimated SEA and SEAc from this object
  SEA[j] <- SE$SEA
  SEAc[j] <- SE$SEAc
  
  # plot the standard ellipse with d.f. = 2 (i.e. SEAc)
  # These are plotted here as thick solid lines
  lines(SE$xSEAc,SE$ySEAc,col=j,lty=1,lwd=3)
  
  
  # Also, for comparison we can fit and plot the convex hull
  # the convex hull is plotted as dotted thin lines
  #
  # Calculate the convex hull for the jth group's isotope values
  # held in the objects created using split() called spx and spy
  CH <- convexhull(spx[[j]],spy[[j]])
  
  # Extract the area of the convex hull from this object
  TA[j] <- CH$TA
  
  # Plot the convex hull
  lines(CH$xcoords,CH$ycoords,lwd=1,lty=3)

  # you can if you want also calculate the 6 layman metrics
  # for this group, although I do not recommned making quantiative
  # comparisons owing to the sample size bias and uncertainties
  # illustrated in my SIBER paper. This is after all why we are 
  # fitting ellipses to our data in this script!
  
  tmp <- laymanmetrics(spx[[j]],spy[[j]])
  
  group.layman.metrics[j,2:7] <- c(tmp$dN_range,
                                   tmp$dC_range,
                                   tmp$hull$TA,
                                   tmp$CD,
                                   tmp$MNND,
                                   tmp$SDNND)
  
}

# print the area metrics to screen for comparison
# NB if you are working with real data rather than simulated then you wont be
# able to calculate the population SEA (pop.SEA)
# If you do this enough times or for enough groups you will easily see the
# bias in SEA as an estimate of pop.SEA as compared to SEAc which is unbiased.
# Both measures are equally variable.
print(cbind(SEA,SEAc,TA))
```






